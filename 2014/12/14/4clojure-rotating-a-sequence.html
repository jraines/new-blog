<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <link href="../../../stylesheets/syntax.css" rel="stylesheet" type="text/css" />
    <link href="../../../stylesheets/main.css" rel="stylesheet" type="text/css" />

    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    <title>Jeremy Raines - 4Clojure: rotating a sequence</title>

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
  </head>
  <body>
    <div id="main" role="main">
      <h1>Rotating a sequence</h1>

<p>The problem:</p>

<blockquote>
<p>Write a function which can rotate a sequence in either direction.</p>
</blockquote>

<p>Such that:</p>
<pre><code class="highlight clojure"><span class="w">  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">your-fn</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span></code></pre>

<p>and</p>
<pre><code class="highlight clojure"><span class="w">  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">your-fn</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">])</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span></code></pre>

<h2>My solution</h2>

<p>A recursive loop where the function that takes the loop closer to completion and the function that recurses on the collection
differ depending on we&rsquo;re rotating &ldquo;backwards&rdquo; or &ldquo;forwards&rdquo;.</p>

<p>It is ugly in the case of negative values because the <code>into</code> is O(n), and that&rsquo;s called n times.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
    </span><span class="n">v</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">pos?</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="nb">dec</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w">
          </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">pos?</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
              </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[(</span><span class="nb">last</span><span class="w"> </span><span class="n">v</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">v</span><span class="p">)))]</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">))))</span><span class="w">
</span></code></pre>

<h2>Two better solutions and why I missed them</h2>

<h3>chouser&rsquo;s solution:</h3>
<pre><code class="highlight clojure"><span class="w">  </span><span class="o">#</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">%2</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">(</span><span class="nb">drop</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cycle</span><span class="w"> </span><span class="n">%2</span><span class="p">))))</span><span class="w">
</span></code></pre>

<p>I was missing two key insights that are required for this more elegant
solution. One is &ldquo;thinking lazy&rdquo; to create an infinite seq of the passed-in
sequence repeated over and over.  Once you have you just need to put your
<code>(count n)</code> long &ldquo;window&rdquo; in the right place.</p>

<p>This is where <code>mod</code> comes in.  <code>(mod % c)</code> gives you the number of items to
skip before placing the front of the &ldquo;window&rdquo;.  This skipping and placement of
the &ldquo;window&rdquo; is accomplished by the paired <code>take</code> and <code>drop</code>.  It would not
have occurred to me to <code>drop</code> from an infinite sequence, because I neglected to
&ldquo;think lazy&rdquo; and understand that that concept isn&rsquo;t realized until the <code>take</code>
is attempted.</p>

<h3>quant1&rsquo;s solution:</h3>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">x</span><span class="p">))]</span><span class="w">
                  </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="p">(</span><span class="nb">drop</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span><span class="w">
</span></code></pre>

<p>I started down this path, but because the <code>mod</code> insight did not occur to me, I
gave up after being unable to <code>take</code> or <code>drop</code> negative numbers.  I messed with
<code>subvec</code> for a few mins before implementing my solution.</p>

    </div>
  </body>
</html>
